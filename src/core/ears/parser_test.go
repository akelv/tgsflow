package ears

import (
	"testing"

	antlr "github.com/antlr4-go/antlr/v4"
	earsp "github.com/kelvin/tgsflow/src/core/ears/gen/src/core/ears"
)

// parseRequirement parses text and returns the concrete alt matched inside RequirementContext.
// Alt numbers are generated by ANTLR; we assert via which sub-rule is non-nil.
func parseRequirement(t *testing.T, text string) *earsp.RequirementContext {
	t.Helper()
	input := antlr.NewInputStream(text)
	lexer := earsp.NewearsLexer(input)
	stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
	parser := earsp.NewearsParser(stream)
	ctx := parser.Requirement().(*earsp.RequirementContext)
	if parser.HasError() {
		t.Fatalf("unexpected syntax error for input: %q", text)
	}
	return ctx
}

func matchedAlt(ctx *earsp.RequirementContext) string {
	switch {
	case ctx.UbiquitousReq() != nil:
		return "ubiquitous"
	case ctx.EventReq() != nil:
		return "event"
	case ctx.StateReq() != nil:
		return "state"
	case ctx.ComplexReq() != nil:
		return "complex"
	case ctx.UnwantedReq() != nil:
		return "unwanted"
	default:
		return ""
	}
}

func TestParser_FormsTable(t *testing.T) {
	cases := []struct {
		name  string
		input string
		want  string
	}{
		{name: "ubiquitous/the", input: "the system shall respond appropriately", want: "ubiquitous"},
		{name: "ubiquitous/pronoun", input: "it shall do something useful", want: "ubiquitous"},

		{name: "event/the", input: "when user clicks, the system shall open dialog", want: "event"},
		{name: "event/pronoun", input: "when user clicks, it shall open dialog", want: "event"},

		{name: "state/the", input: "while battery low, the device shall reduce brightness", want: "state"},
		{name: "state/pronoun", input: "while battery low, it shall reduce brightness", want: "state"},

		{name: "complex/the", input: "while user is logged in and on settings, when save pressed, the system shall store preferences", want: "complex"},
		{name: "complex/pronoun", input: "while preconditions are true, when trigger fires, it shall act", want: "complex"},

		{name: "unwanted/no-pre/the", input: "if error occurs, then the system shall log it", want: "unwanted"},
		{name: "unwanted/no-pre/pronoun", input: "if error occurs, then it shall log it", want: "unwanted"},
		{name: "unwanted/with-pre/the", input: "while maintenance window active, if error occurs, then the system shall defer restart", want: "unwanted"},
		{name: "unwanted/with-pre/pronoun", input: "while maintenance window active, if error occurs, then it shall defer restart", want: "unwanted"},

		// Exercise token_word variants within clause: include keywords inside trigger clause which grammar permits.
		{name: "event/trigger-with-if-then-words", input: "when if flag then toggled, the sys shall proceed", want: "event"},

		// Exercise Response branch that allows COMMA tokens repetitively.
		{name: "event/response-with-commas", input: "when signal received, the system shall a, b, c, continue", want: "event"},
	}
	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			ctx := parseRequirement(t, tc.input)
			got := matchedAlt(ctx)
			if got != tc.want {
				t.Fatalf("alt mismatch: want=%s got=%s for input=%q", tc.want, got, tc.input)
			}
		})
	}
}

// Helper returning both parser and requirement context for advanced API coverage
func parseWithParser(t *testing.T, text string) *earsp.RequirementContext {
	t.Helper()
	input := antlr.NewInputStream(text)
	lexer := earsp.NewearsLexer(input)
	stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
	parser := earsp.NewearsParser(stream)
	ctx := parser.Requirement().(*earsp.RequirementContext)
	if parser.HasError() {
		t.Fatalf("unexpected syntax error for input: %q", text)
	}
	return ctx
}

func TestParser_Walks_BaseListener_AllForms(t *testing.T) {
	sentences := []string{
		"the when if then module shall accept input, and, continue",
		"when user clicks, the system shall open dialog",
		"while battery low, the device shall reduce brightness",
		"while a and b, when trigger happens, the subsystem alpha shall produce output, possibly with, commas",
		"while maintenance window active, if error occurs, then the system shall defer restart",
		"if error occurs, then it shall log it",
	}
	for _, s := range sentences {
		ctx := parseWithParser(t, s)
		antlr.ParseTreeWalkerDefault.Walk(&earsp.BaseearsListener{}, ctx)
		// Also call EnterRule/ExitRule explicitly to hit generated context methods
		ctx.EnterRule(&earsp.BaseearsListener{})
		ctx.ExitRule(&earsp.BaseearsListener{})
	}
}

func TestParser_GeneratedAccessors_AreExercised(t *testing.T) {
	// Complex form with THE system to touch most accessors
	root := parseWithParser(t, "while user is logged in, when save pressed, the system shall store preferences, persist, and notify")
	// Requirement helpers
	_ = root.GetRuleContext()
	_ = root.ToStringTree(nil, nil)
	root.EnterRule(&earsp.BaseearsListener{})
	root.ExitRule(&earsp.BaseearsListener{})
	// ComplexReq context and token accessors
	c := root.ComplexReq()
	if c == nil {
		t.Fatalf("expected complexReq ctx")
	}
	_ = c.WHILE()
	_ = c.Preconditions()
	_ = c.AllCOMMA()
	_ = c.COMMA(0)
	_ = c.COMMA(1)
	_ = c.WHEN()
	trg := c.Trigger()
	_ = trg
	trg.EnterRule(&earsp.BaseearsListener{})
	trg.ExitRule(&earsp.BaseearsListener{})
	_ = trg.ToStringTree(nil, nil)
	_ = c.SHALL()
	resp := c.Response()
	_ = resp
	_ = c.THE()
	_ = c.System()
	_ = c.PRONOUN() // may be nil in this alt
	c.EnterRule(&earsp.BaseearsListener{})
	c.ExitRule(&earsp.BaseearsListener{})
	_ = c.ToStringTree(nil, nil)
	// Trigger/Clause accessors
	clause := trg.Clause()
	_ = clause.AllToken_word()
	_ = clause.Token_word(0)
	clause.EnterRule(&earsp.BaseearsListener{})
	clause.ExitRule(&earsp.BaseearsListener{})
	_ = clause.ToStringTree(nil, nil)
	if tw, ok := clause.Token_word(0).(*earsp.Token_wordContext); ok {
		_ = tw.THE()
		_ = tw.WHEN()
		_ = tw.IF()
		_ = tw.THEN()
		_ = tw.WORD()
		tw.EnterRule(&earsp.BaseearsListener{})
		tw.ExitRule(&earsp.BaseearsListener{})
		_ = tw.ToStringTree(nil, nil)
	}
	// System accessors: ensure multiple token words present via earlier sentence
	sys := c.System()
	if sys != nil {
		_ = sys.AllToken_word()
		_ = sys.Token_word(0)
		sys.EnterRule(&earsp.BaseearsListener{})
		sys.ExitRule(&earsp.BaseearsListener{})
		_ = sys.ToStringTree(nil, nil)
	}
	// Response accessors: token words and commas
	if resp != nil {
		_ = resp.AllToken_word()
		_ = resp.Token_word(0)
		_ = resp.AllCOMMA()
		_ = resp.COMMA(0)
		resp.EnterRule(&earsp.BaseearsListener{})
		resp.ExitRule(&earsp.BaseearsListener{})
		_ = resp.ToStringTree(nil, nil)
	}

	// Also exercise other forms' token accessors
	// Event (PRONOUN branch)
	evtRoot := parseWithParser(t, "when user clicks, it shall open dialog, quickly")
	evt := evtRoot.EventReq()
	if evt == nil {
		t.Fatalf("expected eventReq ctx")
	}
	_ = evt.WHEN()
	_ = evt.Trigger()
	_ = evt.COMMA()
	_ = evt.SHALL()
	_ = evt.PRONOUN()
	_ = evt.THE() // nil on pronoun alt
	evt.EnterRule(&earsp.BaseearsListener{})
	evt.ExitRule(&earsp.BaseearsListener{})
	_ = evt.ToStringTree(nil, nil)
	// State (THE branch)
	stRoot := parseWithParser(t, "while battery low, the device shall reduce brightness, smoothly")
	st := stRoot.StateReq()
	if st == nil {
		t.Fatalf("expected stateReq ctx")
	}
	_ = st.WHILE()
	_ = st.Preconditions()
	_ = st.COMMA()
	_ = st.SHALL()
	_ = st.THE()
	_ = st.System()
	st.EnterRule(&earsp.BaseearsListener{})
	st.ExitRule(&earsp.BaseearsListener{})
	_ = st.ToStringTree(nil, nil)
	// Unwanted without preconditions (PRONOUN branch) + with preconditions (THE branch)
	uw1Root := parseWithParser(t, "if error occurs, then it shall log it, immediately")
	uw1 := uw1Root.UnwantedReq()
	if uw1 == nil {
		t.Fatalf("expected unwantedReq ctx (no preconditions)")
	}
	_ = uw1.IF()
	_ = uw1.Trigger()
	_ = uw1.COMMA(0)
	_ = uw1.THEN()
	_ = uw1.SHALL()
	_ = uw1.PRONOUN()
	uw1.EnterRule(&earsp.BaseearsListener{})
	uw1.ExitRule(&earsp.BaseearsListener{})
	_ = uw1.ToStringTree(nil, nil)
	uw2Root := parseWithParser(t, "while maintenance window active, if error occurs, then the system shall defer restart")
	uw2 := uw2Root.UnwantedReq()
	if uw2 == nil {
		t.Fatalf("expected unwantedReq ctx (with preconditions)")
	}
	_ = uw2.WHILE()
	_ = uw2.Preconditions()
	_ = uw2.IF()
	_ = uw2.COMMA(0)
	_ = uw2.COMMA(1)
	_ = uw2.THEN()
	_ = uw2.THE()
	_ = uw2.System()
	uw2.EnterRule(&earsp.BaseearsListener{})
	uw2.ExitRule(&earsp.BaseearsListener{})
	_ = uw2.ToStringTree(nil, nil)

	// Ubiquitous (PRONOUN and THE) detailed accessors
	ubi1 := parseWithParser(t, "it shall perform operation, with, details").UbiquitousReq()
	if ubi1 == nil {
		t.Fatalf("expected ubiquitousReq ctx (pronoun)")
	}
	_ = ubi1.PRONOUN()
	_ = ubi1.SHALL()
	_ = ubi1.Response()
	ubi1.EnterRule(&earsp.BaseearsListener{})
	ubi1.ExitRule(&earsp.BaseearsListener{})
	_ = ubi1.ToStringTree(nil, nil)
	ubi2 := parseWithParser(t, "the core when if then module shall operate when needed").UbiquitousReq()
	if ubi2 == nil {
		t.Fatalf("expected ubiquitousReq ctx (the)")
	}
	_ = ubi2.THE()
	_ = ubi2.System()
	_ = ubi2.SHALL()
	_ = ubi2.Response()
	ubi2.EnterRule(&earsp.BaseearsListener{})
	ubi2.ExitRule(&earsp.BaseearsListener{})
	_ = ubi2.ToStringTree(nil, nil)

	// Ubiquitous with empty response
	ubiEmpty := parseWithParser(t, "it shall").UbiquitousReq()
	if ubiEmpty == nil {
		t.Fatalf("expected ubiquitousReq ctx (empty response)")
	}
	_ = ubiEmpty.PRONOUN()
	_ = ubiEmpty.SHALL()
	_ = ubiEmpty.Response()
	ubiEmpty.EnterRule(&earsp.BaseearsListener{})
	ubiEmpty.ExitRule(&earsp.BaseearsListener{})
	_ = ubiEmpty.ToStringTree(nil, nil)

	// Ubiquitous with comma-only response
	ubiCommas := parseWithParser(t, "it shall , , ,").UbiquitousReq()
	if ubiCommas == nil {
		t.Fatalf("expected ubiquitousReq ctx (comma-only response)")
	}
	r := ubiCommas.Response()
	if r != nil {
		_ = r.AllCOMMA()
		if len(r.AllCOMMA()) > 0 {
			_ = r.COMMA(0)
		}
		r.EnterRule(&earsp.BaseearsListener{})
		r.ExitRule(&earsp.BaseearsListener{})
		_ = r.ToStringTree(nil, nil)
	}

	// Exercise Preconditions context methods explicitly
	pre := c.Preconditions()
	if pre != nil {
		pre.EnterRule(&earsp.BaseearsListener{})
		pre.ExitRule(&earsp.BaseearsListener{})
		_ = pre.ToStringTree(nil, nil)
		cl := pre.Clause()
		_ = cl
	}
}

func TestParser_ComponentRules_BasicWalk(t *testing.T) {
	// Exercise component rules via a complex sentence and walk children to touch many nodes.
	ctx := parseRequirement(t, "while a and b, when trigger happens, the subsystem alpha shall produce output, possibly with, commas")
	var visited int
	var walk func(n antlr.Tree)
	walk = func(n antlr.Tree) {
		visited++
		switch r := n.(type) {
		case antlr.RuleContext:
			for _, ch := range r.GetChildren() {
				walk(ch)
			}
		}
	}
	walk(ctx)
	if visited == 0 {
		t.Fatalf("expected to visit some nodes in parse tree")
	}
}
